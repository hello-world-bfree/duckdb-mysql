# name: test/sql/covering_index.test
# description: Test covering index detection for cost model optimization
# group: [sql]

#
# This test validates that FindCoveringIndex correctly identifies when an index
# covers all columns needed by a query (SELECT + WHERE columns), enabling
# index-only scans with reduced I/O cost (70% reduction in cost model).
#
# A covering index allows MySQL to satisfy the query entirely from the index
# without accessing the table data pages.

require mysql_scanner

require-env MYSQL_TEST_DATABASE_AVAILABLE

statement ok
SET GLOBAL mysql_experimental_filter_pushdown=true

statement ok
ATTACH 'host=localhost user=root port=0 database=mysqlscanner' AS s1 (TYPE MYSQL_SCANNER)

# ==============================================================================
# Test Setup: Create table with various indexes for covering index tests
# ==============================================================================

statement ok
DROP TABLE IF EXISTS s1.covering_idx_test

statement ok
CREATE TABLE s1.covering_idx_test(
    id INTEGER PRIMARY KEY,
    indexed_a INTEGER NOT NULL,
    indexed_b INTEGER NOT NULL,
    indexed_c INTEGER NOT NULL,
    non_indexed VARCHAR(200)
)

# Create composite index that can cover queries on (indexed_a, indexed_b, indexed_c)
statement ok
CALL mysql_execute('s1', 'CREATE INDEX idx_abc ON covering_idx_test(indexed_a, indexed_b, indexed_c)')

# Create another index for single column coverage
statement ok
CALL mysql_execute('s1', 'CREATE INDEX idx_b ON covering_idx_test(indexed_b)')

statement ok
INSERT INTO s1.covering_idx_test
SELECT
    range as id,
    range % 100 as indexed_a,
    range % 1000 as indexed_b,
    range % 50 as indexed_c,
    REPEAT('x', 100) as non_indexed
FROM range(10000)

statement ok
CALL mysql_execute('s1', 'ANALYZE TABLE covering_idx_test')

statement ok
CALL mysql_clear_cache()

# ==============================================================================
# Test 1: Query fully covered by composite index (indexed_a, indexed_b, indexed_c)
# SELECT and WHERE use only columns in the index
# ==============================================================================

query I
SELECT indexed_a FROM s1.covering_idx_test WHERE indexed_a = 50
----
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50
50

query I
SELECT COUNT(*) FROM s1.covering_idx_test WHERE indexed_a = 50
----
100

# ==============================================================================
# Test 2: Query with multiple columns from covering index
# ==============================================================================

query I
SELECT COUNT(*) FROM s1.covering_idx_test
WHERE indexed_a = 25 AND indexed_b < 500
----
50

query I
SELECT COUNT(*) FROM s1.covering_idx_test
WHERE indexed_a = 0 AND indexed_b = 0 AND indexed_c = 0
----
10

# ==============================================================================
# Test 3: Aggregate query covered by index
# ==============================================================================

query I
SELECT SUM(indexed_b) FROM s1.covering_idx_test WHERE indexed_a = 10
----
46000

query I
SELECT AVG(indexed_c)::INTEGER FROM s1.covering_idx_test WHERE indexed_a < 10
----
4

query I
SELECT COUNT(DISTINCT indexed_b) FROM s1.covering_idx_test WHERE indexed_a = 5
----
10

# ==============================================================================
# Test 4: Query NOT covered by index (requires table access)
# non_indexed column forces table lookup
# ==============================================================================

query I
SELECT COUNT(*) FROM s1.covering_idx_test
WHERE indexed_a = 50 AND LENGTH(non_indexed) > 50
----
100

query I
SELECT COUNT(*) FROM s1.covering_idx_test
WHERE indexed_a = 25
----
100

# ==============================================================================
# Test 5: Primary key as covering index
# PK index always covers the id column
# ==============================================================================

query I
SELECT id FROM s1.covering_idx_test WHERE id = 5000
----
5000

query I
SELECT id FROM s1.covering_idx_test WHERE id BETWEEN 100 AND 110
----
100
101
102
103
104
105
106
107
108
109
110

# ==============================================================================
# Test 6: Single column index coverage
# idx_b covers queries selecting only indexed_b with filter on indexed_b
# ==============================================================================

query I
SELECT COUNT(*) FROM s1.covering_idx_test WHERE indexed_b = 500
----
10

query I
SELECT indexed_b FROM s1.covering_idx_test WHERE indexed_b = 999 LIMIT 5
----
999
999
999
999
999

# ==============================================================================
# Test 7: Partial coverage scenarios
# Some columns in index, some not - no covering index benefit
# ==============================================================================

query I
SELECT COUNT(*) FROM s1.covering_idx_test
WHERE indexed_a = 10 AND indexed_b = 10
----
10

# Adding non-indexed column breaks coverage
query I
SELECT COUNT(*) FROM s1.covering_idx_test
WHERE indexed_a = 10
----
100

# ==============================================================================
# Test 8: Complex queries with covering index potential
# ==============================================================================

query II
SELECT indexed_a, COUNT(*) as cnt FROM s1.covering_idx_test
WHERE indexed_b < 100
GROUP BY indexed_a
ORDER BY indexed_a
LIMIT 5
----
0	10
1	10
2	10
3	10
4	10

query I
SELECT MAX(indexed_c) FROM s1.covering_idx_test WHERE indexed_a = 99
----
49

# ==============================================================================
# Test 9: Verify correctness regardless of covering index optimization
# ==============================================================================

query I
SELECT SUM(indexed_a + indexed_b + indexed_c) FROM s1.covering_idx_test
WHERE indexed_a = 42
----
57600

query II
SELECT MIN(indexed_b), MAX(indexed_b) FROM s1.covering_idx_test
WHERE indexed_a = 0
----
0	900

# ==============================================================================
# Cleanup
# ==============================================================================

statement ok
DROP TABLE IF EXISTS s1.covering_idx_test

statement ok
DETACH s1
